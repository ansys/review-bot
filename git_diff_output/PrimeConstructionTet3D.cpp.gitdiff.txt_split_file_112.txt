chatGPTInstruction:62+
 bool PrimeConstructionTet3D::createTetMesh(cm2::intersect_t3::mesher::data_type &dataAllRemeshed)
 {
     // access dataAllRemeshed: Here you find the data for the boundary mesh
@@ -34,26 +76,99 @@ bool PrimeConstructionTet3D::createTetMesh(cm2::intersect_t3::mesher::data_type
     // m_tetData.total_time      : need to be discussed - time in seconds
 
     // Note: The nodal ids stored in connectM and connectB must be using the same nodal ids
+    // re-create ancestors and neighbors from tetData
 
-    // re create ancestors and neighbors from tetData
-    m_ancestors.clear();
-    int ret = cm2::meshtools::get_ancestors(m_tetData.connectM, m_ancestors);
-    if (ret != 0)
-        m_occData->addMsg("get_ancestors: The " + std::to_string(ret) + " -th argument had an illegal value ", CADErrorHandler::GetAncestors);
+    PrimeFileIO fileio(this);
+    bool foundDiscardedFaces = false;
 
-    m_neighbors.clear();
-    bool accept_multiple_neighbors = false;
-    int ret1 = cm2::meshtools::get_neighbors(m_tetData.connectM, cm2::CM2_TETRA4, accept_multiple_neighbors, m_neighbors);
-    if (ret1 != 0)
-        m_occData->addMsg("get_neighbors: The " + std::to_string(ret1) + " -th argument had an illegal value )", CADErrorHandler::GetNeighbors);
+    std::string absPath = m_occData->getAbsoluteDebugOutputPath();
+    std::string unique_name = m_occData->getOriginalFileBaseName() + "_" + std::to_string(uniqueBaseIdentifier());
+
+    /*create a prime directory to store all the debug file in it*/
+    int ret_d = fileio.CreateDirectory("prime");
+    if (ret_d)
+        std::cout << "the prime directory has been successfully created -> " << std::endl;
+
+    /*The code to write the boundary mesh file in the directory*/
+    CGAL::Real_timer fileWriterTime;
+    fileWriterTime.start();
+    fileio.writeBoundaryMesh(dataAllRemeshed);
+    m_dPrimeFileIODuration += fileWriterTime.time();
+    fileWriterTime.stop();
+
+    /*The code for placing the Generate_vol.py file in prime debug folder*/
+    fileio.GenerateVolumePyFile();
+
+    /*The code for generating the run Prime sh file */
+    fileio.CreatePrimeShellScript();
+
+    /*Running the shell script to kick off prime container */
+    CGAL::Real_timer tetMeshDuration;
+    tetMeshDuration.start();
+    fileio.RunPrimeShellScript(m_occData);
+    m_tetData.total_time = tetMeshDuration.time();
+    tetMeshDuration.stop();
+
+    /*Now that the shell script has been used, Read the volumeMesh file */
+    CGAL::Real_timer fileReaderTime;
+    fileReaderTime.start();
+    int ret_1 = fileio.ReadVolumeMesh(
+        m_tetData, m_occData, foundDiscardedFaces); // ReadPrimeData(f , m_tetData.pos, m_tetData.connectM , ~m_tetData.connectB  , m_tetData.colors )
+    m_dPrimeFileIODuration += fileReaderTime.time();
+    fileReaderTime.stop();
+    if (!ret_1)
+    {
+        std::cout << "failed to read the Volume mesh" << std::endl;
+        return false;
+    }
+
+    /*Check whether discarderd faces are there */
+    if (foundDiscardedFaces)
+    {
+        m_iTetmesherWarningCode = cm2::tetramesh_iso::mesher::data_type::CM2_FACE_DISCARDED;
+        m_occData->addMsg("found discarded faces after prime volume meshing");
+    }
+
+    /*Updating the shape qualities feature*/
+    updateShapeQualities();
+
+    /*Updating the ancestors and neighbours features */
+    updateAncestorsAndNeighbours();
 
-    // you can use this to check that the tet mesh data have been properly transferred back
-    if (m_occData->isAddDebugInfoFlag() >= 4)
+    /*Filling the connectB alternative way*/
+    m_tetData.connectB.clear();
+    int ret2 = cm2::meshtools::get_colors_boundaries(m_tetData.connectM, m_tetData.neighbors, m_tetData.colors, cm2::element_type::CM2_TETRA4, true,
+                                                     m_tetData.connectB);
+
+    if (ret2 != 0)
     {
+        m_occData->addMsg("get_mesh_boundaries : The " + std::to_string(ret2) + "-th argument had an illegal value");
+    }
+
+    if (m_occData->isAddDebugInfoFlag() >= 5)
+    {
+        /*generating output for the tet mesh */
         std::stringstream ss;
-        ss << m_occData->getDebugOutputPath() << "/" << getBaseName() << ".tetMesh"
-           << ".vtk";
-        m_occData->addMsg("Writing vtk debug file: " + ss.str());
+        ss << m_occData->getDebugOutputPath() << "/debug.prime.tetMesh." << unique_name << ".vtk";
+        m_occData->addMsg("Writing vtk debug file for volume mesh : " + ss.str());
         cm2::meshtools::vtk_output(ss.str().c_str(), m_tetData.pos, m_tetData.connectM, cm2::element_type::CM2_TETRA4);
+
+        /*generating output for the boundary mesh */
+        std::stringstream ss_;
+        ss_ << m_occData->getDebugOutputPath() << "/debug.prime.boundaryMesh." << unique_name << ".vtk";
+        m_occData->addMsg("Writing vtk debug file for boundary mesh : " + ss_.str());
+        cm2::meshtools::vtk_output(ss_.str().c_str(), m_tetData.pos, m_tetData.connectB, cm2::element_type::CM2_FACET3);
+
+        std::stringstream ss3;
+        ss3 << m_occData->getDebugOutputPath() << "/debug.prime.tetMesh." << unique_name << ".bdf";
+        cm2::IntVec fe_types;  // The types of element stored in each block
+        cm2::UIntVec xConnect; // The block indices. The i-th block in connect starts at xConnect[i] and ends at xConnect[i+1]
+        fe_types.push_back(cm2::element_type::CM2_TETRA4);
+        xConnect.push_back(0);
+        xConnect.push_back((int)m_tetData.connectM.cols());
+
+        cm2::meshtools::NASTRAN_output(ss3.str().c_str(), m_tetData.pos, m_tetData.connectM, xConnect, fe_types, m_tetData.colors);
     }
+
+    return true;
 }
\ No newline at end of file
